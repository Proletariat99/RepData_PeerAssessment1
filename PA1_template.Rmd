# Reproducible Research: Peer Assessment 1


## Loading and preprocessing the data

Below, the data are read using read.csv, then incomplete cases are eliminated and I split the data frame using split by $date.  

```{r echo=TRUE}
options(scipen=4)
activity_filename <- "activity.csv"
act <- read.csv(activity_filename, stringsAsFactors=FALSE)
complete_act <- act[complete.cases(act),]
bydate_act <- split(complete_act, complete_act$date, drop=TRUE)
coltest <- bydate_act[[1]][1:3,1:3]
print(coltest)
```


## What is mean total number of steps taken per day?

This code calculates the mean # of steps taken per day by taking the split data sets and looping over them to sum the steps per day and then append to a list, then takes the mean & median of the list.  


```{r echo=TRUE}
c <- complete_act #lazeh
a <- bydate_act  #lazy
daily_steps <- vector()
for(date in bydate_act){
 daily_steps <- append(daily_steps, as.numeric(sum(date$steps)))
#  mean(bydate_act[["2012-11-29"]]$"steps")      # just for future use, if necessary 
}
myhist <- hist(daily_steps)
daily_mean <- mean(daily_steps)
daily_median <- median(daily_steps)
```

The mean of the per-day steps is `r daily_mean`   
The median of the per-day steps is `r daily_median`

## What is the average daily activity pattern?
```{r fig.width=7, fig.height=6, echo=TRUE}
by_interval_act <- split(complete_act, complete_act$interval, drop=TRUE)

interval_steps <- vector()
for(interval in by_interval_act){
  interval_steps <- append(interval_steps, sum(interval$steps))
}

plot(interval_steps, type="l", ylab = "Steps Per Interval", xlab = "Interval Identifier")
max_interval <- which.max(interval_steps)
```

The interval with the most steps is interval `r max_interval`


## Imputing missing values

Calculating the # of cases containing NA values.  I 

```{r echo=TRUE}
total_count <- length(act$date)
temp <- act[complete.cases(act),]
complete_count <- length(temp$date)
no_of_na <- total_count - complete_count
```

I feel like this is kind of cheating, but I just took the total # of cases and subtracted the # of complete cases to get the total # of cases containing NA's.  

The number of cases containing an NA is `r no_of_na`



```{r}
mydf <- data.frame()
bydate_all_act <- split(act, act$date)
for(l in bydate_all_act){
    daymean <- mean(l$steps, na.rm = TRUE)
    l$steps[is.na(l$steps)] <- daymean
    mydf <- rbind(l)
    }
    
    
# if(is.na(l)==TRUE){
#     mydf <- data.frame(bydate_all_act[l$date[1]])  # totally arbitrary number... they're all the same
#     names(mydf) <- c("steps", "date", "interval")
#     day_avg <- mean(mydf$steps)
#     print(day_avg)
#     } else {print("not NA")}
# }    
# # bydate_means <- bydate_act$"steps")
# bydate_means <- aggregate(act$steps, by=list(act$date), mean, na.action = na.omit)
# names(bydate_means) <- c("date", "mean")
# i=1
# for(d in names(bydate_act)){
#   filler <- bydate_means$mean[i]
#   bydate_act[[d]]$steps[which(is.na(bydate_act[[d]]$steps))] <- filler
#   i=i+1 # I know... not very imaganinative... running out of time
#   
# }
# filled_act <- bydate_act
# Actually filled the bydate_act, since we'll use this data set going forward.  Also 
```

Now making a histogram of hte total steps per day with the filled values:
```{r}
# filled_daily_steps <- vector()
# for(dd in bydate_act){
#  filled_daily_steps <- append(filled_daily_steps, as.numeric(sum(dd$steps)))
#  mean(bydate_act[["2012-11-29"]]$"steps")      # just for future use, if necessary
# hist(mydf$steps)
```


Glargh... I'm out of time, but I was very close.  Here's the pseudocode:

For(line in activityDataFrame){
  
  if (line$steps == NA){line$steps <- mean(activityDataFrame[line$date])} else {print("something snarky")}
}

## Are there differences in activity patterns between weekdays and weekends?
